/*
 * 2848869
 * 8089098
 * 3861852
 */

package hashAndSalt

import (
	"bytes"
	"crypto/rand"
	"crypto/sha512"
	"io"
	"log"
	"os"
)

// inspired by: https://socketloop.com/tutorials/golang-securing-password-with-salt

const saltSize = 8

// Generates a salt based on a password and a randomly generated byte array
func GenerateSalt(secret []byte) []byte {
	buf := make([]byte, saltSize, saltSize+sha512.Size)
	_, err := io.ReadFull(rand.Reader, buf)

	if err != nil {
		log.Printf("random read failed: %v", err)
		os.Exit(1)
	}

	hash := sha512.New()
	hash.Write(buf)
	hash.Write(secret)
	return hash.Sum(buf)
}

// Combines the password and the salt and hashes the result
func GeneratePasswordAndSaltHash(salt, password []byte) []byte { // generate password + salt hash to store into the file
	combination := string(salt) + string(password)
	passwordHash := sha512.New()
	_, err := io.WriteString(passwordHash, combination)
	if err != nil {
		log.Printf("passwordHash could not be generated: %v", err)
	}
	return passwordHash.Sum(nil)
}

// Checks the entered password with the existing one
func Match(enteredPassword, hashedPassword, salt []byte) bool {
	return bytes.Equal(GeneratePasswordAndSaltHash(salt, enteredPassword), hashedPassword)
}
